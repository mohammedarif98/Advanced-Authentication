

To ensure that JWT tokens (both access and refresh) work correctly and refresh the access token when it expires, we need to update and correct a few aspects of your code. Specifically, the refresh token logic and its integration with the flow of generating a new access token from the refresh token should be addressed. Here's a breakdown of the changes:

Refresh Token Logic: We need to create an endpoint for refreshing the access token using the refresh token. This will ensure that after the access token expires, a valid refresh token can generate a new access token without needing to log in again.

Token Validation: We'll add a middleware that verifies the refresh token and generates a new access token when needed.

Clearer Error Handling: We can improve error handling, especially around the token validation steps.

Step-by-Step Correction
1. JWT Token (Access Token & Refresh Token)
No major changes are required in this section, but we need to ensure that tokens are properly signed and checked for expiration.

js
Copy code
import jwt from "jsonwebtoken";

// Sign a new access token
const signAccessToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_ACCESS_SECRET_KEY, {
    expiresIn: process.env.JWT_ACCESS_EXPIRES_IN,
  });
};

// Sign a new refresh token
const signRefreshToken = (id) => {
  return jwt.sign({ id }, process.env.JWT_REFRESH_SECRET_KEY, {
    expiresIn: process.env.JWT_REFRESH_EXPIRES_IN,
  });
};

// Send tokens when signing up or logging in
const createSendToken = (user, statusCode, res, message) => {
  const accessToken = signAccessToken(user._id);
  const refreshToken = signRefreshToken(user._id);

  const cookieOptions = {
    expires: new Date(
      Date.now() + process.env.JWT_REFRESH_EXPIRES_IN * 24 * 60 * 60 * 1000
    ),
    httpOnly: true,
    secure: process.env.NODE_ENV === "production", // only secure in production
    sameSite: process.env.NODE_ENV === "production" ? "none" : "Lax",
  };

  res.cookie("refreshToken", refreshToken, cookieOptions); // Set refresh token in cookie

  // Hide sensitive data
  user.password = undefined;
  user.otp = undefined;
  user.confirmPassword = undefined;

  const { username, email, _id } = user;          // Destructure non-sensitive user info

  return res.status(statusCode).json({
    status: "success",
    message,
    accessToken,
    userData: { username, email, _id },
  });
};

export { createSendToken, signAccessToken, signRefreshToken };
2. Middleware for Token Authentication
Here, we ensure the access token is checked. We will also add a route for refreshing the access token.

js
Copy code
import jwt from "jsonwebtoken";
import { catchAsync } from "../utils/catchAsync.js";
import User from "../models/userModel.js";

// Middleware for access token verification
export const isAuthenticated = catchAsync(async (req, res, next) => {
  const token = req.cookies.accessToken || req.headers.authorization?.split(" ")[1];
  if (!token) return next(new customErrorHandler("You are not logged in! Please log in to get access.", 401));

  try {
    const decoded = jwt.verify(token, process.env.JWT_ACCESS_SECRET_KEY);
    const currentUser = await User.findById(decoded.id);
    if (!currentUser) return next(new customErrorHandler("User not found", 403));
    
    req.user = currentUser;
    next();
  } catch (err) {
    return next(new customErrorHandler("Token is invalid or has expired", 403));
  }
});

// Middleware for refresh token verification and generating a new access token
export const refreshAccessToken = catchAsync(async (req, res, next) => {
  const refreshToken = req.cookies.refreshToken;

  if (!refreshToken) {
    return next(new customErrorHandler("Refresh token is missing", 403));
  }

  try {
    const decoded = jwt.verify(refreshToken, process.env.JWT_REFRESH_SECRET_KEY);

    // Check if user still exists
    const user = await User.findById(decoded.id);
    if (!user) return next(new customErrorHandler("User not found", 403));

    // Generate a new access token
    const newAccessToken = signAccessToken(user._id);

    return res.status(200).json({
      status: "success",
      accessToken: newAccessToken,
    });
  } catch (err) {
    return next(new customErrorHandler("Refresh token is invalid or has expired", 403));
  }
});
3. AuthController: Sign Up and Verify Account
This remains mostly as is, except error handling is improved slightly.

js
Copy code
// Signup Controller remains the same (from the code you posted above)
4. Routes: Add Refresh Token Route
We now need to add the route that allows the client to refresh the access token using the refresh token.

js
Copy code
import express from "express";
const router = express.Router();
import { signUp, verifyUserAccount } from "../controllers/authController.js";
import { isAuthenticated, refreshAccessToken } from "../middleware/isAuthenticated.js";

// Route for signing up
router.post("/signup", signUp);

// Route for verifying user
router.post("/verify", isAuthenticated, verifyUserAccount);

// Route for refreshing access token
router.post("/refresh-token", refreshAccessToken);

export default router;
5. Client-Side Logic for Token Refresh
Make sure your frontend requests a new access token when the current access token expires. Hereâ€™s how you might handle it:

Detect a 403/401 (unauthorized) response when trying to access a protected route.
Send a request to /refresh-token to get a new access token.
Retry the original request with the new access token.
js
Copy code
// Example of retrying request after access token expiration
axios.interceptors.response.use(
  (response) => response,
  async (error) => {
    const originalRequest = error.config;

    if (error.response.status === 403 && !originalRequest._retry) {
      originalRequest._retry = true;

      // Request a new access token
      const { data } = await axios.post("/api/refresh-token");
      const newAccessToken = data.accessToken;

      // Set new access token in headers and retry the original request
      originalRequest.headers["Authorization"] = `Bearer ${newAccessToken}`;

      return axios(originalRequest);
    }

    return Promise.reject(error);
  }
);
Summary
The refresh token logic is implemented as a separate endpoint (/refresh-token).
The access token is validated through the isAuthenticated middleware.
Once the access token expires, the client sends a request to the /refresh-token route to get a new access token using the refresh token stored in cookies.
This way, the user remains logged in without re-entering credentials unless both tokens expire.